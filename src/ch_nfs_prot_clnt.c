/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include <stddef.h>
#include <string.h> /* for memset */
#include "nfs_prot.h"
#ifndef USE_RPCLIB
#include "ch_nfs_prot_xdr.c"
#endif

#include "rpc/clnt_audp.h"

/*
 * Sun RPC is a product of Sun Microsystems, Inc. and is provided for
 * unrestricted use provided that this legend is included on all tape
 * media and as a part of the software program in whole or part.  Users
 * may copy or modify Sun RPC without charge, but are not authorized
 * to license or distribute it to anyone else except as part of a product or
 * program developed by the user or with the express written consent of
 * Sun Microsystems, Inc.
 *
 * SUN RPC IS PROVIDED AS IS WITH NO WARRANTIES OF ANY KIND INCLUDING THE
 * WARRANTIES OF DESIGN, MERCHANTIBILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE OR TRADE PRACTICE.
 *
 * Sun RPC is provided with no support and without any obligation on the
 * part of Sun Microsystems, Inc. to assist in its use, correction,
 * modification or enhancement.
 *
 * SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE
 * INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY SUN RPC
 * OR ANY PART THEREOF.
 *
 * In no event will Sun Microsystems, Inc. be liable for any lost revenue
 * or profits or other special, indirect and consequential damages, even if
 * Sun has been advised of the possibility of such damages.
 *
 * Sun Microsystems, Inc.
 * 2550 Garcia Avenue
 * Mountain View, California  94043
 */
/*
 * Copyright (c) 1987, 1990 by Sun Microsystems, Inc.
 */

/* from @(#)nfs_prot.x	1.3 91/03/11 TIRPC 1.0 */

/* ask user what to do on timeot */

extern int RPCTimeoutReq(void);

static enum clnt_stat
ch_clnt_call(CLIENT *rh,
	     u_long proc,
	     xdrproc_t xargs,
	     void * argsp,
	     xdrproc_t xres,
	     void * resp,
	     struct timeval timeout)
{
    int val;

    while(val = clnt_call(rh, proc, xargs, argsp, xres, resp, timeout))
    {
	struct rpc_err clerr;
	
	clnt_geterr(rh, &clerr);
	if(clerr.re_status != RPC_TIMEDOUT)
	    return val;
	if(!RPCTimeoutReq())
	    return val;
    }
    return val;
}

#undef clnt_call
#define clnt_call ch_clnt_call

/* Default timeout can be changed using clnt_control() */
static struct timeval TIMEOUT = { 25, 0 };

#if 0
void *
nfsproc_null_2(void *argp, CLIENT *clnt)
{
	static char clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call(clnt, NFSPROC_NULL, xdr_void, argp, xdr_void, &clnt_res, TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return ((void *)&clnt_res);
}
#endif

attrstat *
nfsproc_getattr_2(nfs_fh *argp, CLIENT *clnt)
{
	static attrstat clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call(clnt, NFSPROC_GETATTR, xdr_nfs_fh, argp, xdr_attrstat, &clnt_res, TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

attrstat *
nfsproc_setattr_2(sattrargs *argp, CLIENT *clnt)
{
	static attrstat clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call(clnt, NFSPROC_SETATTR, xdr_sattrargs, argp, xdr_attrstat, &clnt_res, TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

void *
nfsproc_root_2(void *argp, CLIENT *clnt)
{
	static char clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call(clnt, NFSPROC_ROOT, xdr_void, argp, xdr_void, &clnt_res, TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return ((void *)&clnt_res);
}

diropres *
nfsproc_lookup_2(diropargs *argp, CLIENT *clnt)
{
	static diropres clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call(clnt, NFSPROC_LOOKUP, xdr_diropargs, argp, xdr_diropres, &clnt_res, TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

readlinkres *
nfsproc_readlink_2(nfs_fh *argp, CLIENT *clnt)
{
	static readlinkres clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call(clnt, NFSPROC_READLINK, xdr_nfs_fh, argp, xdr_readlinkres, &clnt_res, TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

readres *
nfsproc_read_2(readargs *argp, CLIENT *clnt)
{
	static readres clnt_res;
	static char buf[8192];

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	clnt_res.readres_u.reply.data.data_val = buf;
	if (clnt_call(clnt, NFSPROC_READ, xdr_readargs, argp, xdr_readres, &clnt_res, TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

readres *
nfsproc_read_buf(readargs *argp, CLIENT *clnt, char *buf)
{
	static readres clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	clnt_res.readres_u.reply.data.data_val = buf;

	if (clnt_call(clnt, NFSPROC_READ, xdr_readargs, argp, xdr_readres, &clnt_res, TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

int
nfsproc_send_read_buf(readargs *argp, CLIENT *clnt, readres *clnt_res,
		      char *buf, void *userdata)
{
	memset((char *)clnt_res, 0, sizeof(*clnt_res));
	clnt_res->readres_u.reply.data.data_val = buf;

	if (clnt_send(clnt, NFSPROC_READ,
		      xdr_readargs, argp,
		      xdr_readres, clnt_res,
		      userdata) != RPC_TIMEDOUT)
	{
		return (0);
	}
	return (1);
}

readres *
nfsproc_wait_read_buf(CLIENT *clnt, void **userdata)
{
    if (clnt_wait(clnt, TIMEOUT) != RPC_SUCCESS)
    {
	return (NULL);
    }
    *userdata = clnt_getuserdata(clnt);
    return ((readres *) clnt_getwaitres(clnt)); /* FIXME: could be output parameter of clnt_wait */
}
#if 0
readres *
nfsproc_check_read_buf(CLIENT *clnt)
{
    struct timeval NOTIMEOUT = { 0, 0 };

    memset((char *)&clnt_res, 0, sizeof(clnt_res));
    if (((res = clnt_wait(clnt, NOTIMEOUT)) != RPC_SUCCESS)
	&& (res != RPC_TIMEDOUT))
    {
	return (NULL);
    }
    return (clnt_getwaitres(clnt)); /* FIXME: coud be output parameter of clnt_wait */
}
#endif

void *
nfsproc_writecache_2(void *argp, CLIENT *clnt)
{
	static char clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call(clnt, NFSPROC_WRITECACHE, xdr_void, argp, xdr_void, &clnt_res, TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return ((void *)&clnt_res);
}

attrstat *
nfsproc_write_2(writeargs *argp, CLIENT *clnt)
{
	static attrstat clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call(clnt, NFSPROC_WRITE, xdr_writeargs, argp, xdr_attrstat, &clnt_res, TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

static attrstat clnt_res; /* FIXME */

attrstat *
nfsproc_wait_write_2(CLIENT *clnt)
{
    memset((char *)&clnt_res, 0, sizeof(clnt_res));
    if (clnt_wait(clnt, TIMEOUT) != RPC_SUCCESS)
    {
	return (NULL);
    }
    return (&clnt_res);
}

attrstat *
nfsproc_check_write_2(CLIENT *clnt, int *error_flag)
{
    enum clnt_stat res;
    struct timeval NOTIMEOUT = { 0, 0 };

    memset((char *)&clnt_res, 0, sizeof(clnt_res));
    if ((res = clnt_wait(clnt, NOTIMEOUT)) != RPC_SUCCESS)
    {
	*error_flag = (res != RPC_TIMEDOUT);
	return (NULL);
    }
    return (&clnt_res);
}

#if 1
bool_t
xdr_writeargssb(XDR *xdrs, writeargs *objp); /* FIXME */
#endif

int
nfsproc_send_writesb_2(writeargs *argp, CLIENT *clnt)
{
    memset((char *)&clnt_res, 0, sizeof(clnt_res));
    if(clnt_sendsb(clnt, NFSPROC_WRITE, xdr_writeargssb, argp,
		   xdr_attrstat, &clnt_res,
		   NULL,
		   argp->data.data_val, argp->data.data_len
		   ) != RPC_TIMEDOUT)
    {
	return (0);
    }
    return (1);
}

int
nfsproc_send_write_2(writeargs *argp, CLIENT *clnt)
{
	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if(clnt_send(clnt, NFSPROC_WRITE,
		     xdr_writeargs, argp,
		     xdr_attrstat, &clnt_res, NULL) != RPC_TIMEDOUT)
	{
		return (0);
	}
	return (1);
}

diropres *
nfsproc_create_2(createargs *argp, CLIENT *clnt)
{
	static diropres clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call(clnt, NFSPROC_CREATE, xdr_createargs, argp, xdr_diropres, &clnt_res, TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

nfsstat *
nfsproc_remove_2(diropargs *argp, CLIENT *clnt)
{
	static nfsstat clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call(clnt, NFSPROC_REMOVE, xdr_diropargs, argp, xdr_nfsstat, &clnt_res, TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

nfsstat *
nfsproc_rename_2(renameargs *argp, CLIENT *clnt)
{
	static nfsstat clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call(clnt, NFSPROC_RENAME, xdr_renameargs, argp, xdr_nfsstat, &clnt_res, TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

nfsstat *
nfsproc_link_2(linkargs *argp, CLIENT *clnt)
{
	static nfsstat clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call(clnt, NFSPROC_LINK, xdr_linkargs, argp, xdr_nfsstat, &clnt_res, TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

nfsstat *
nfsproc_symlink_2(symlinkargs *argp, CLIENT *clnt)
{
	static nfsstat clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call(clnt, NFSPROC_SYMLINK, xdr_symlinkargs, argp, xdr_nfsstat, &clnt_res, TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

diropres *
nfsproc_mkdir_2(createargs *argp, CLIENT *clnt)
{
	static diropres clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call(clnt, NFSPROC_MKDIR, xdr_createargs, argp, xdr_diropres, &clnt_res, TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

nfsstat *
nfsproc_rmdir_2(diropargs *argp, CLIENT *clnt)
{
	static nfsstat clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call(clnt, NFSPROC_RMDIR, xdr_diropargs, argp, xdr_nfsstat, &clnt_res, TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

readdirres *
nfsproc_readdir_2(readdirargs *argp, CLIENT *clnt)
{
	static readdirres clnt_res;

	if(clnt_res.readdirres_u.reply.entries)
	    xdr_free(xdr_readdirres, &clnt_res);

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call(clnt, NFSPROC_READDIR, xdr_readdirargs, argp, xdr_readdirres, &clnt_res, TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

statfsres *
nfsproc_statfs_2(nfs_fh *argp, CLIENT *clnt)
{
	static statfsres clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call(clnt, NFSPROC_STATFS, xdr_nfs_fh, argp, xdr_statfsres, &clnt_res, TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}
